use clap::ArgMatches;
use std::{
    fs::File,
    io::{Read, Seek, SeekFrom, Write},
    collections::BTreeSet
};

use crate::extract_config_path;

// ============================= Local Author Storage (LAS)
// ========== ADD-NEW (add a new author to local author storage)
// sigrs add_new
// * identity cannot be duplicated, but username/email can be
// == with params (required to pass all 3 if hard passing params)
// sigrs add --identity "some_id" --username "fluxdiv" --email "xxx@email.com"
// * or, user can pass multiple usernames/emails at once
// sigrs add --id "someid" --usernames "fluxdiv" "john" --emails "x@e.com" "y@e.com"
pub fn handle_add_new(args: &ArgMatches) -> Result<(), String> {
    // TODO: If --identity is not passed, interactive prompt
    let Some(identity) = args.get_one::<String>("identity") else {
        return Err(String::from("Identity is required for add-new"));
    };

    // --identity was passed, extract emails & usernames
    let usernames: Vec<String> = args
        .get_many::<String>("usernames")
        .map(|vals| vals.cloned().collect())
        .ok_or_else(|| String::from("Usernames required if --identity provided"))?;

    let emails: Vec<String> = args
        .get_many::<String>("emails")
        .map(|vals| vals.cloned().collect())
        .ok_or_else(|| String::from("Emails required if --identity provided"))?;

    let config_path = extract_config_path(args)?;

    let mut config_handle = File::options()
        .read(true)
        .write(true)
        .create(true)
        .open(&config_path)
        .map_err(|e| format!("Problem opening/creating config file: {:?}", e))?;

    let mut file_content = String::new();
    config_handle.read_to_string(&mut file_content).unwrap();

    // If didn't exist and new config was created, add top line comment
    if file_content.is_empty() {
        config_handle.set_len(0).unwrap();
        config_handle.seek(SeekFrom::Start(0)).unwrap();
        config_handle.write_all(b"# File generated by signatu_rs. Do not manually edit this file. #\n").unwrap();
    } else {
        // validate identity doesn't already exist
        // could use memmap here but I'm already copying file anyway
        for line in file_content.lines() {
            if let Some(key_line) = line.strip_prefix("K:") {
                if key_line.trim_matches('"') == identity {
                    return Err(format!("Identity \"{}\" already exists", identity));
                }
            }
        }
    }

    config_handle.seek(SeekFrom::End(0)).unwrap();

    let mut entry_text = String::new();
    // key line
    entry_text.push_str("K:");
    entry_text.push_str(&format!("\"{}\"\n", identity));

    // usernames line
    entry_text.push_str("U:");
    for uname in usernames.iter() {
        entry_text.push_str(&format!("\"{}\"", uname));
    }
    entry_text.push_str("\n");

    // emails line
    entry_text.push_str("E:");
    for email in emails.iter() {
        entry_text.push_str(&format!("\"{}\"", email));
    }
    entry_text.push_str("\n");

    // write entry
    config_handle.write_all(entry_text.as_bytes()).unwrap();

    Ok(())
}


// ========== UPDATE (update an existing author in local author storage)
// ==== only used to add/change something, use DELETE to remove something
// ==== requires --identity param, and at least 1 other option
// == additions
// sigrs update --identity "some-key" --add-username "guy" --add-email "x@e.com"
// sigrs update --identity "some-key" --add-usernames ["guy", "guy"] --add-emails ...
// == changes
// sigrs update --identity "some-key" --change-identity "other-key"
// sigrs update --identity "some-key" --change-email --old="x@e.com" --new="y@e.com"
// sigrs update --identity "some-key" --change-username --old="guy" --new="bob"
pub fn handle_update(args: &ArgMatches) -> Result<(), String> {

    let identity = args.get_one::<String>("identity")
        .ok_or_else(|| String::from("--identity required"))?;

    let config_path = extract_config_path(args)?;

    // Get file handle, do not create if didn't exist - nothing ot update
    let mut config_handle = File::options()
        .read(true)
        .write(true)
        .open(&config_path)
        .map_err(|e| format!("Problem opening config file: {:?}", e))?;

    let mut file_content = String::new();
    config_handle.read_to_string(&mut file_content).unwrap();
    assert!(!file_content.is_empty());

    let mut line_iter = file_content.lines();
    let mut new_file_content = String::new();
    let mut found = false;

    while let Some(line) = line_iter.next() {
        // If comment line, add & continue
        if line.starts_with("#") {
            new_file_content.push_str(line);
            new_file_content.push('\n');
            continue;
        }

        // If key line, check identity matches
        if line.starts_with("K:") {
            // unwrappable unless file format wrong
            let uname_line = line_iter.next().unwrap();
            let email_line = line_iter.next().unwrap();

            // If identity doesn't match, add identity & continue
            let id_key = line.trim_matches(&['K', ':', '"']);
            if id_key != identity {
                new_file_content.push_str(line);
                new_file_content.push('\n');
                new_file_content.push_str(uname_line);
                new_file_content.push('\n');
                new_file_content.push_str(email_line);
                new_file_content.push('\n');
                continue;
            }

            // Identity matched
            found = true;
            // handle modifications, then push rest of lines
            if let Some(new_identity) = args.get_one::<String>("change-identity") {
                new_file_content.push_str(&format!("K:\"{}\"\n", new_identity));
            } else {
                new_file_content.push_str(line);
                new_file_content.push('\n');
            }

            // Username mod
            let mut uname_mod = uname_line.to_string();
            modify_line(LineType::UsernameLine(&mut uname_mod), args);
            new_file_content.push_str(&uname_mod);
            new_file_content.push('\n');

            // Username mod
            let mut email_mod = email_line.to_string();
            modify_line(LineType::EmailLine(&mut email_mod), args);
            new_file_content.push_str(&email_mod);
            new_file_content.push('\n');
        }
    }

    if !found {
        return Err(String::from("Identity does not exist"));
    }

    config_handle.set_len(0)
        .map_err(|e| format!("Cannot alter file size: {:?}", e))?;
    config_handle.seek(SeekFrom::Start(0))
        .map_err(|e| format!("Cannot seek start of file: {:?}", e))?;
    config_handle.write_all(new_file_content.as_bytes())
        .map_err(|e| format!("Cannot update file: {:?}", e))?;

    Ok(())
}

enum LineType<'l> {
    UsernameLine(&'l mut String),
    EmailLine(&'l mut String)
}

// Takes in a line & args, updates that line
fn modify_line(l: LineType<'_>, args: &ArgMatches) -> () {
    // this is modifying value passed in, not bidning, which should be fine since it's
    // allocated & not memmapped here
    let (fmt, line) = match l {
        LineType::UsernameLine(uline) => ("username", uline),
        LineType::EmailLine(eline) => ("email", eline)
    };

    // Removals done before additions

    let remove_all_flag = args.get_flag(&format!("remove-all-{}s", fmt));

    if remove_all_flag {
        // set line to just U: or E:
        line.replace_range(2.., "");
    } else {
        // Remove each individually
        let maybe_remove_many: Option<Vec<String>> = args
            .get_many::<String>(&format!("remove-{}", fmt))
            .map(|vals| vals.cloned().collect());
        
        if let Some(remove_many) = maybe_remove_many {
            for remove in remove_many.iter() {
                // alright commit
                // find pattern, remove it as long as start > 2
                if let Some(start) = line.find(remove) {
                    // start > 2 incase "remove" is "U:" etc.
                    if start > 2usize {
                        // replace -1 && + 1 to remove quotes 
                        line.replace_range((start - 1)..=(remove.len() + 1), "");
                    }
                }
            }
        }
    }

    // additions
    let maybe_add_many: Option<Vec<String>> = args
        .get_many::<String>(&format!("add-{}", fmt))
        .map(|vals| vals.cloned().collect());

    if let Some(add_many) = maybe_add_many {
        // The easy way to prevent dupes but comes with allocation
        let mut x: BTreeSet<String> = BTreeSet::new();
        for add in add_many.iter() {
            // create entry with wrapping "", add to line
            if x.insert(format!("\"{}\"", add)) {
                line.push('\"');
                line.push_str(add);
                line.push('\"');
            }
        }
    }
}

