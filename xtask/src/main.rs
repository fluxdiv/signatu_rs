// use core::panic;
use std::{
    env,
    fs::File,
    ffi::OsString,
    io::Write,
    os::unix::ffi::OsStrExt,
    panic::resume_unwind,
    path::{Path, PathBuf},
    process::{Command, Stdio},
    sync::Arc,
    thread
};
use anyhow::Result;
use std::os::unix::ffi::OsStringExt;

fn main() -> Result<(), String> {
    let task = env::args().nth(1);
    match task.as_deref() {
        Some("build") => build()?,
        _ => eprintln!("Must use build as arg"),
    }
    Ok(())
}

fn build() -> Result<(), String> {

    let cargo = env::var("CARGO").unwrap_or_else(|_| String::from("cargo"));

    let project_root = Path::new(&env!("CARGO_MANIFEST_DIR"))
        .ancestors()
        .nth(1)
        .unwrap()
        .to_path_buf();
    // project_root.push("core");

    let install_status = Command::new(cargo)
        .current_dir(&project_root)
        .args(&["install", "--path", "core", "--bins", "--features", "sigrs_function"])
        // .args(&["install", "--path", "."])
        .status()
        .map_err(|e| e.to_string())?;

    if !install_status.success() {
        return Err(String::from("cargo install --path . failed"));
    }

    // call sigrs_function get-bin-path
    let output = Command::new("sigrs_function")
        .current_dir(&project_root)
        .arg("get-bin-path")
        .output()
        .map_err(|e| e.to_string())?;

    let bin_path = OsString::from_vec(output.stdout);

    // create default config && append path to bin
    // -------------------
    let config_dir_path = {
        let tmp = dirs::config_dir()
            .ok_or_else(|| String::from("Cannot get default config dir"))?;
        Ok::<Arc<PathBuf>, String>(Arc::new(tmp))
    }?;

    let create_cfg = Arc::clone(&config_dir_path);
    let create_cfg_handle = thread::spawn(move || {
        create_default_config(create_cfg)
    });

    let append = Arc::clone(&config_dir_path);
    let append_handle = thread::spawn(move || {
        append_to_bin(append, bin_path)
    });

    match create_cfg_handle.join() {
        Ok(v) => {
            if let Err(e) = v {
                resume_unwind(e);
            }
        },
        Err(e) => resume_unwind(e)
    };

    match append_handle.join() {
        Ok(v) => {
            if let Err(e) = v {
                resume_unwind(e)
            }
        },
        Err(e) => resume_unwind(e)
    };

    Ok(())
}

const EMPTY_CONFIG: &'static str = r#"# File generated by signatu_rs. Do not manually edit this file. #
"#;

fn create_default_config(config_dir_path: Arc<PathBuf>) -> thread::Result<()> {

    std::env::set_current_dir(config_dir_path.as_ref()).unwrap();
    std::fs::create_dir("sigrs").unwrap();
    
    let config_path = {
        let mut tmp = (*config_dir_path).clone();
        tmp.push("sigrs");
        tmp.push("config.sigrs");
        tmp
    };

    // TODO probably should fail if config already exists
    let mut config_handle = File::options()
        .read(true).write(true).create_new(true)
        .open(config_path.as_path())
        .unwrap();

    let empty_cfg = EMPTY_CONFIG.as_bytes();
    config_handle.write_all(empty_cfg).unwrap();

    Ok(())
}

fn append_to_bin(config_dir_path: Arc<PathBuf>, bin_path: OsString) -> thread::Result<()> {

    let config_path = {
        let mut tmp = (*config_dir_path).clone();
        tmp.push("sigrs");
        tmp.push("config.sigrs");
        tmp
    };

    // open bin_path
    let mut bin_handle = File::options()
        .write(true).append(true)
        .open(bin_path)
        .unwrap();

    // generate config_path with hex len
    let cfg_path = config_path.as_path().as_os_str().as_bytes();
    let mut data: Vec<u8> = Vec::with_capacity(cfg_path.len() + 8);
    data.write_all(cfg_path).unwrap();

    let cfg_len_u32 = u32::try_from(cfg_path.len()).unwrap();
    let cfg_len_hex_str = format!("{:08X}", cfg_len_u32);
    let hexstr_bytes = cfg_len_hex_str.as_bytes();
    if hexstr_bytes.len() != 8 {
        panic!("Error converting config path len to hex");
    }
    data.write_all(hexstr_bytes).unwrap();

    // write to end of bin
    bin_handle.write_all(&data).unwrap();

    Ok(())
}



